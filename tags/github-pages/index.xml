<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Github Pages on 개발지식공작소</title>
    <link>http://brannpark.github.io/blog/tags/github-pages/</link>
    <description>Recent content in Github Pages on 개발지식공작소</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Tue, 01 Dec 2015 15:36:31 +0900</lastBuildDate>
    <atom:link href="http://brannpark.github.io/blog/tags/github-pages/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Made by HUGO and GitHub Pages</title>
      <link>http://brannpark.github.io/blog/posts/20151201_hugo_with_github_pages/</link>
      <pubDate>Tue, 01 Dec 2015 15:36:31 +0900</pubDate>
      
      <guid>http://brannpark.github.io/blog/posts/20151201_hugo_with_github_pages/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;일반적인 웹사이트의 경우, 여러 웹 컨텐츠들을 다이내믹 하게 생성하여 이용자에게 전달한다.&lt;/p&gt;

&lt;p&gt;다시 말해서, 웹어플리케이션이 동적 컨텐츠를 정적 컨텐츠로 변환하는 과정을 수행한다.&lt;/p&gt;

&lt;p&gt;그러다 보니, 이렇게 생성된 동적 컨텐츠는 일반적으로 브라우저 레벨에서의 캐싱을 이용할 수 없다. 따라서 매 페이지 요청시 마다 웹어플리케이션이 반복적인 일을 해야한다. &lt;strike&gt;내가 힘드냐 기계가 힘들지&lt;/strike&gt;&lt;/p&gt;

&lt;p&gt;정적 컨텐츠가 컨텐츠의 대부분을 차지하는 사이트의 경우에는 Static Website 를 만들어서 운영해 볼 수 있다. 이 방법이 나름 재미있다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;hugo:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Hugo&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; 는 Static Website Engine 이다. 이녀석은 사용자가 만든 컨텐츠를 이용, 이를 정적 웹사이트 컨텐츠로 만들어낸다.&lt;/p&gt;

&lt;p&gt;또한 특정 테마를 지정하여 빠르고 쉽게 사이트의 레이아웃과 스타일을 만들어 낼 수 있다.&lt;/p&gt;

&lt;p&gt;이 모든 과정은 사용자의 로컬 호스트에서 이뤄진다. 그러나 내 로컬에 결과물을 만들어낸 것만으로는 사이트를 인터넷에 띄울 수 없다.&lt;/p&gt;

&lt;p&gt;이 결과물을 GitHub, Amazon S3, 기타 클라우드 스토리지(public url access 가능한) 등에 업로드 하여 내 사이트를 인터넷에 띄우게 된다.&lt;/p&gt;

&lt;p&gt;본 블로그는 보다시피 Github Pages 를 이용하여 호스팅되고 있으며, Hugo 가이드를 마치고 호스팅에 대한 이야기를 이어 가겠다.&lt;/p&gt;

&lt;h2 id=&#34;installation:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;설치과정은 다음과 같다.&lt;/p&gt;

&lt;p&gt;본인은 Mac 을 쓰기에 Homebrew 를 이용한 설치 방법을 따랐지만, 그 외의 &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;다양한 플랫폼에 설치하는 방법&lt;/a&gt;을 제공한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;단순하다. hugo는 사이트 URL(gohugo.io) 에서도 알 수 있듯이 go 기반으로 작성되어있기에 의존 패키지와 같은 복잡한 설치 과정 없이 심플하게 설치된다.&lt;/p&gt;

&lt;h2 id=&#34;create-hugo-project:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Create Hugo Project&lt;/h2&gt;

&lt;p&gt;/usr/local/bin 에 hugo 바이너리가 위치하며 이를 이용해 새 스켈레톤 프로젝트를 생성할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd /path/to/workspace
$ hugo new site &amp;lt;sitename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;생성된 파일 및 디렉토리 구조는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  ▸ archetypes/
  ▸ content/
  ▸ data/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자동 생성된 각 디렉토리에 대한 간단한 셜명을 하자면,&lt;/p&gt;

&lt;h3 id=&#34;archetypes:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;archetypes&lt;/h3&gt;

&lt;p&gt;hugo new 명령어로 컨텐츠를 생성 시, 자동으로 생성되는 header 템플릿을 생성하고자 하는 컨텐츠의 타입에 맞게 커스터마이징 가능하다.&lt;/p&gt;

&lt;p&gt;예를 들어, /content/musician 의 서브디렉토리 구조가 존재하는 경우,&lt;/p&gt;

&lt;p&gt;/archetypes/posts.md 라는 파일을 생성하여 내용을 다음과 같이 작성한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
name = &amp;quot;&amp;quot;
bio = &amp;quot;&amp;quot;
genre = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;hugo new musician/mozart.md&lt;/code&gt; 의 명령어를 수행하면
위에 지정된 name, bio, genre 구문이 header 에 추가로 자동 생성되는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;content:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;content&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;hugo new &amp;lt;path/to/&amp;gt;filename.md&lt;/code&gt; 명령어 수행 시 생성된 마크다운 문서가 저장되는 곳&lt;/p&gt;

&lt;h3 id=&#34;data:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;data&lt;/h3&gt;

&lt;p&gt;사이트 생성 시 필요한 추가적인 데이터를 저장할 수 있는 곳이다.
toml 의 형식으로 variable 을 선언하고 특정 데이터를 assign 가능하다.
또한 data 디렉토리의 하위 디렉토리 구조를 이용하여 데이터의 계층구조를 만들어 낼 수 있으며 같은 디렉토리내의 여러 toml 파일들은 Array 로 처리되어진다.
좀 복잡하게 다음과 같이 data 디렉토리가 구성되어있고&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/data/human/info/a.toml&lt;/code&gt;, &lt;code&gt;/data/human/info/b.toml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;각각의 a.toml, b.toml 의 내용이 다음과 같다면&lt;/p&gt;

&lt;p&gt;[ a.toml ]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name = &amp;quot;Steve&amp;quot;
age = 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[ b.toml ]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;name = &amp;quot;Peter&amp;quot;
age = 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이를 html 템플릿에서 다음과 같이 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range $.Site.Data.human.info }}
&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;Name : {{ .name }}&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Age  : {{ .age }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;layouts:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;layouts&lt;/h3&gt;

&lt;p&gt;테마에서 사용되는 HTML 템플릿 파일들을 overwrite 할 수 있는 곳&lt;/p&gt;

&lt;h3 id=&#34;static:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;static&lt;/h3&gt;

&lt;p&gt;테마에서 사용되는 asset 을 overwrite 하거나, 추가 asset 들을 제공할 수 있는 곳&lt;/p&gt;

&lt;h2 id=&#34;select-theme:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Select Theme&lt;/h2&gt;

&lt;p&gt;Hugo 에는 다양한 오픈소스 테마들이 존재한다.
&lt;a href=&#34;http://themes.gohugo.io&#34;&gt;이곳&lt;/a&gt;에서 Hugo 의 다양한 테마들을 살펴볼 수 있다.&lt;/p&gt;

&lt;p&gt;본 블로그에 적용된 테마는 &lt;a href=&#34;http://themes.gohugo.io/redlounge/&#34;&gt;RedLounge&lt;/a&gt; 라는 테마이다.&lt;/p&gt;

&lt;p&gt;먼저, 적용하고자 하는 테마의 git 저장소 URL을 확인한다. 그리고, 사이트 프로젝트 root 에서 다음과 같은 명령어들을 수행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mkdir themes
$ cd themes
$ git clone &amp;lt;repository_url_of_theme&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다운받은 테마를 살펴보면, 기본 구조가 &lt;code&gt;hugo new site&lt;/code&gt; 를 통해 만들어진 구조와 거의 흡사하다는것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;RedLounge 테마를 기준으로 분석해보니&amp;hellip;&lt;/p&gt;

&lt;p&gt;content 와 data 디렉토리가 없는 대신 images 디렉토리가 존재한다.&lt;/p&gt;

&lt;p&gt;또한, config.toml 대신 theme.toml 설정파일이 존재한다.&lt;/p&gt;

&lt;p&gt;images 디렉토리는 Hugo의 ThemeShowcase 를 위한 이미지파일을 제공하며, theme.toml 또한 테마에 대한 설명, 버젼, 작성자 등에 대한 정보를 제공하는데에 쓰인다.&lt;/p&gt;

&lt;p&gt;hugo 는 프로젝트를 빌드 시, 테마의 파일시스템을 임시 파일시스템위에 카피하고, 다시 이곳에 사용자 프로젝트의 파일시스템을 덮어씌운 결과물을 빌드하는 것으로 보인다. 그러므로 theme 의 레이아웃 파일을 overwrite 하고 싶다면 동일한 stucture 내의 동일한 이름의 컨텐츠 파일을 생성하여 overwrite 가능하다.&lt;/p&gt;

&lt;h2 id=&#34;configuration:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;Hugo 프로젝트의 설정파일. toml, yaml, json 모두 사용 가능하다.
자세한 내용은 &lt;a href=&#34;https://gohugo.io/overview/configuration/&#34;&gt;이곳&lt;/a&gt;을 참조하여 확인하자.&lt;/p&gt;

&lt;h2 id=&#34;create-page:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Create Page&lt;/h2&gt;

&lt;p&gt;새 페이지를 만들기 위해서는 다음과 같은 명령어를 이용한다&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new content/newpost.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;혹은, 서브 URL 형태로 컨텐츠를 제공 하고자 한다면&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo new content/&amp;lt;subdir&amp;gt;/newpost.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;와 같이 명령어를 수행하여 새 컨텐츠를 생성한다.&lt;/p&gt;

&lt;p&gt;이렇게 생성된 md 파일은 다음과 같은 특수한 header 부분을 가진다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
Categories = [&amp;quot;Development&amp;quot;]
Description = &amp;quot;Hugo와 GitHub Pages 를 이용한 블로그 구축 가이드&amp;quot;
Tags = [&amp;quot;hugo&amp;quot;, &amp;quot;redlounge&amp;quot;, &amp;quot;static-website-engine&amp;quot;, &amp;quot;github-pages&amp;quot;]
date = &amp;quot;2015-12-01T15:36:31+09:00&amp;quot;
title = &amp;quot;Made by HUGO and GitHub Pages&amp;quot;
+++

&amp;lt;Markdown Content&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는, 본 게시글에 적용된 header 로 각각은 테마와 연동되어 사이트의 UI에 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;github-pages:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;GitHub Pages&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://pages.github.com&#34;&gt;Pages&lt;/a&gt; 는 github repository 를 기반으로 웹사이트를 호스팅해주는 기능이다.&lt;/p&gt;

&lt;p&gt;github의 username 을 이용하여, 다음과 같이 내 github.io 에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그러나 위와 같은 식으로 접근하여 사이트를 호스팅 하려면 다음과 같은 특수한 이름의 저장소를 만들어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 저장소의 master 브랜치에 index.html 을 만들어 remote 에 푸쉬해 두면, 위 링크 접속 시 해당 페이지를 브라우저에서 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이를 Pages 에서는 User/Organization Site 라 한다.&lt;/p&gt;

&lt;p&gt;이와 별개로, 각각의 저장소들은 각각의 Pages 를 가질 수 있는데, 이를 Project site 라 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository_name&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 blog 라는 저장소를 가지고 있다면, blog 저장소에 gh-pages 라는 브랜치를 orphan 모드로 생성(기존의 브랜치, 커밋들에서 완전히 독립적인 새 브랜치)하여 index.html 만들어 remote 에 푸쉬 해 두면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io/blog&lt;/code&gt; 에 접속 시 해당 페이지를 브라우저에서 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-to-github-pages:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Deploying to GitHub Pages&lt;/h1&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>