<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 개발지식저장소</title>
    <link>http://brannpark.github.io/blog/posts/</link>
    <description>Recent content in Posts on 개발지식저장소</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-KR</language>
    <lastBuildDate>Wed, 15 Jun 2016 19:20:21 +0900</lastBuildDate>
    <atom:link href="http://brannpark.github.io/blog/posts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Presenter First</title>
      <link>http://brannpark.github.io/blog/posts/20160615_presenter_first/</link>
      <pubDate>Wed, 15 Jun 2016 19:20:21 +0900</pubDate>
      
      <guid>http://brannpark.github.io/blog/posts/20160615_presenter_first/</guid>
      <description>

&lt;h1 id=&#34;presenter-first-tdd-for-large-complex-applications-with-graphical-user-interfaces:3945feba508775401f06cd3bcd843e68&#34;&gt;Presenter First: TDD for Large, Complex Applications with Graphical User Interfaces&lt;/h1&gt;

&lt;p&gt;Michael Marsiglia, Brian Harleton, Carl Erickson&lt;/p&gt;

&lt;p&gt;번역: Brann Park
원문: &lt;a href=&#34;https://atomicobject.com/uploadedImages/archive/files/PF_March2005.pdf&#34;&gt;https://atomicobject.com/uploadedImages/archive/files/PF_March2005.pdf&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;motivation:3945feba508775401f06cd3bcd843e68&#34;&gt;Motivation&lt;/h2&gt;

&lt;p&gt;그래픽 사용자 인터페이스는 고통스럽다! 우리 모두가 다 겪어보았다. 그것은 처음 대충 훑어보았을 때는 매우 쉬웠다. 어떻게 우리는 그런 대규모의 혼란스런것들을 빠르게 만들어왔는가? 왜 우리의 디자인에 작은 변화를 가하는 것이 그리도 고통스러운가? 기능에 대해 가장 무지한 시점에, 우리는 어떻게 끊임없이 거대하고 시간이 많이드는 코드의 조각들을 만드어내는 함정에 빠지게 되었는가? 어떻게 우리는 기능 중심 개발의 골로부터 잘못된 길로 들어서게 되었는가? 우리의 스트레스와 고통스러움을 분명히 경감시켜줄 수 있는 유닛 테스트들을 작성하는것이 왜 어려운가? 고객에게 커스텀 다이얼로그 내부의 작은 변화를 가하는것이 한 주(week)의 시간이 소요될 것이라는 것을 어떻게 이야기 할 것인가?&lt;/p&gt;

&lt;p&gt;그 첫 단계는 비지니스 로직과 인터페이스를 분리하는 것이다. Model-View-Presenter 패턴의 용어를 사용하는 것은, Model이 Presenter와 View로 부터 격리된다는 것이다. 이런 테크닉을 이용하여 우리는 비지니스 로직(model)을 유닛 테스트할 수 있고, TDD 원칙을 따를 수 있게된다. 그러나 어플리케이션 흐름, 또는 GUI내에 존재하는 기능을 그대로 내버려두기 때문에 이러한 접근만으로는 충분하지 않다. 자동화 시스템 레벨의 테스트 프레임워크를 이용함으로써 GUI기능을 테스트 할 수 있다. 우리의 경험상, 이러한 테스트 패키지를 만들고 유지보수 하는것은 많은 비용이 든다.&lt;/p&gt;

&lt;p&gt;Michael Feathers의 Humble Dialog Box 는 그래픽 유저 인터페이스를 가진 어플리케이션에서, View로부터 모든 기능과 로직을 제거함으로써 테스트성을 향상시켰다. 이 접근은 Smart Object를 만들고, Presenter를 View로부터 Model로 이동시킨다. 이 Smart Object를 관리하는 것은 사용자 인터페이스의 흐름과 로직이 어플리케이션의 비지니스 로직에 묶이게 되기에 이상적이지 못하다. 어플리케이션 흐름에 대한 모든 변화는 직접적으로 비지니스 로직에 영향을 미치고 반대로 비지니스 로직의 변화 또한 어플리케이션 흐름에 영향을 끼치게 된다. 이러한 커플링 문제때문에 요구사항의 변화는 다루기가 쉽지 않다.&lt;/p&gt;

&lt;p&gt;이상적으로 우리는 비용 효율적인 관점에서, 사용자 우선순위의, 스토리 베이스의, 테스트 주도의 개발이라는 Extreme Programming practices를 따를수 있도록 해주는 접근법을 원한다. 이러한 목표를 달성하기 위해 TDD 개발 프로세스의 도입이 필요하다. 우리는 clean하고, robust하고, decouped하고, 완전히 테스트된 코드를 위해 노력해야 한다. 우리는 요구사항의 변화를 쉽고 저렴하게 만들 코드와 프로세스를 원한다.&lt;/p&gt;

&lt;p&gt;Presenter First는 사용자 그래픽 인터페이스를 가진 복잡한 어플리케이션들과 어플리케이션 패키지들을 만들어내는 문제를 다룬다. 그것은 끊임없이 변화하는 인터페이스로 부터 개발을 분리시키고 기능의 문제에 집중하는데에 도움을 준다. 사용자 스토리들은 일반적으로 기능 중심적이기 때문에, Presenter First는 우리가 버튼, 슬라이더, 체크박스들이 아닌, 기능의 관점에서 생각할 수 있도록 해준다. 또한 Presenter First는 테스트된, 유지보수 가능한 코드를 제공하고, 어플리케이션의 기능 구현 및 테스트를 위한 프로세스를 제공해준다.&lt;/p&gt;

&lt;h2 id=&#34;presenter-first:3945feba508775401f06cd3bcd843e68&#34;&gt;Presenter First&lt;/h2&gt;

&lt;p&gt;Presenter First는 프로세스와 패턴의 결합니다. 패턴은 MVP 디자인 패턴의 변형이다. Presenter First의 프로세스는 MVP를 이용해 어떻게 어플리케이션이 만들어지고 테스트 되는지를 결정한다. 그 결과는 테스트 주도 개발 효과의 경계선을 고객에의해 설명되고 우선순위되어진 시스템 기능을 포함하도록 확장해낸다.&lt;/p&gt;

&lt;p&gt;Acceptance test들은 고객의 관점에서 시스템의 기능성을 검증한다. 고객의 관점이라는 것이 어플리케이션의 인터페이스를 포함하기 때문에 acceptance test 를 자동화하는 접근은 인터페이즈의 자동화를 요구한다. 이런 접근은 복잡하고 비싸며, 특히 인터페이스가 그래픽인 경우 더욱 그러하다. Extreme Programming 커뮤니티의 일반적인 통념으로 보이는 하나의 대안은, GUI를 가능한 얇은 레이어 형태로 만들고 그 바로 아래에서 레이어를 테스트하는 것이다. Presenter First는 이러한 일반적 통념의 구체적인 실현을 제공해준다.&lt;/p&gt;

&lt;p&gt;MVP 패턴은 Taligent에 의해 처음 소개되고, Dolphin에 의해 널리 쓰이고, 가장 최근에는 Fowler 에 의해 소개되어진 SmallTalk의 전통적 MVC 패턴으로 부터 유래되었다. MVP의 의도는 Presentation 에서 비지니스 룰을 분리시키는데에 있지만, 더 나아가 프리젠테이션의 매커니즘으로부터 행위를 분리시키는데에 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Model&lt;/strong&gt; 어플리케이션의 비지니스 로직과 데이터. 고객에게 보이지않으며 관련되어있지 않다.
&lt;strong&gt;View&lt;/strong&gt; 어플리케이션의 인터페이스. 고객에게 있어서는, View가 어플리케이션이다. 고객 스토리는 View에 무언가를 하고 View에서 결과를 보는 관점에서의 기능성을 대해 설명한다. 그 View는 그러므로 프로젝트 전반에 걸쳐 가장 높은 변화율을 가지게 된다. 이러한 변화로부터 디커플링 시키는 것이 Presenter First의 가장 주요한 목적이다.
&lt;strong&gt;Presenter&lt;/strong&gt; Presenter는 Model과 View가 서로 상호작용할 수 있도록 허용해주는 커스텀 로직이다. 이것은 MVP 각각의 요소들의 기능성 또는 흐름을 나타낸다. 고객 스토리들이나 요구사항들은 Presenter안의 기능성과 일치한다.&lt;/p&gt;

&lt;p&gt;Presenter First에서 사용되는 MVP의 변형은 MVP 각각의 요소들 내에서의 커뮤니케이션 패턴들에 영향을 미친다. 본래의 MVP 패턴은 Model이 직접적으로 View 와 커뮤니케이션하는 것을 허용한다. 그러나 Presenter First는 모든 커뮤니케이션이 Presenter를 통해서 이뤄지는 것을 요구한다. 이런 제약은 Model과 View가 서로 격리되는 것을 보장한다. 그리고 MVP 각각의 요소들에 대한 테스트성을 크게 증대시킨다.&lt;/p&gt;

&lt;p&gt;Presenter First의 프로세스 측면은 시간을 지남에 따라 어떻게 개발이 구성되는지, 그리고 개발되는 동안 어플리케이션이 어떻게 테스트되는지에 대한 질문을 던진다. 모든 어플리케이션 개발 노고에서 직면하는 첫번째 질문은 어디에서 시작할 것인가 이다. MVP에 기반한 어플리케이션에게는 다음과 같은 세가지 답변이 가능하다.&lt;/p&gt;

&lt;p&gt;Model에서 시작하는 것은 전통적인 소프트웨어 개발의 &amp;ldquo;infrastructure first&amp;rdquo; 접근의 형태이다. 이 접근의 단점은, 무엇이 필요한지 확실하게 알지못한 채 Model을 만든다는 점과, 초기 개발 시 사용자에게 보이지 않는 것들에 대해 초점을 맞춘다는 것을 포함한다. Model은 테스트하기 쉬워야 하며, 테스트 주도 방식에서 개발하기 쉬워야 한다. 고객으로부터의 기능 요청에 의해 Model에 대한 요구조건들이 명확해질 때까지 작업을 연기하는 것이 핵심이다.&lt;/p&gt;

&lt;p&gt;View에서 시작하는 것은 고객 우선순위 기능 주도 개발 프로세스에서 MVP를 사용할 때 꽤 논리적인듯이 보인다. 이 접근의 논리는 매력적이다. 고객 스토리들은 View에서 일어나는 액션들과 View에서 보여지는 결과, 그들이 어플리케이션을 사용하는데 있어 어떤 인터페이스들이 필요한지에 대한 피드백, 그리고 최소화된 Model(infrastructure)의 중요성을  이야기한다. 불행하게도 View First는 쉽게 만들고 쉽게 비싼 실수를 야기한다.&lt;/p&gt;

&lt;p&gt;View First 개발은 몇몇 약점들을 가지고 있다. View는 고객으로부터의 어떤 확고한 생각들, 특정한 것들을 남겨두는 것에 대한 망설임, 그리고 요구사항을 바꾸는 비율을 높게 만들어내는데 있어 특별하다. 우리의 경험상, 사용자 스토리들을 거의 디테일한 인터페이스들을 명시하지 않는다. 그러나 좀 더 일반적인 어플리케이션 기능을 설명한다. 이렇게 남아있는 모호함은 고객에 의해 인터페이스를 퇴짜놓도록 함으로써 수시간을 단지 인터페이스를 만드는데만 소모하게 할 수 있다. 게다가 View에 초점을 맞추는 것은 View를 비지니스 로직과 함께 두텁게 만드는 위험을 증대시키는 경향이 있다. 마지막으로 인터페이스 테스트의 어려움은, 바람직한 테스트 주도 개발의 사이클을 허물어 버린다.&lt;/p&gt;

&lt;p&gt;우리의 경험에서, 최고의 대안은 Presenter First이다. Presenter에서 시작하고 그 주위에서 개발을 조직함으로써 사용자 스토리로부터 테스트 주도 개발 실행을 따르며 어플리케이션이 만들어질 수 있을 것이다. Presenter에서의 유닛 테스트들은 작성하고 유지하는데 경제적이며, 특정 인터페이스 요소들에 묶이지 않은 채 어플리케이션 기능의 정상 동작을 확인한다. Presenter First로 개발함으로써, 개발자의 관심을 고객 기능에 두면서도 동시에 Model과 View에 대한 최소화된 완전한 명세들이 만들어지게 된다.&lt;/p&gt;

&lt;p&gt;Presenter First는 MVP의 구현 옵션임에도, Model과 View 모두의 인터페이스를 필요로한다. Presenter와의 커뮤니케이션은 Presenter로 부터 Model과 View 모두가 decoupling 된 채 이벤트 서브시스템을 통해서 처리된다.&lt;/p&gt;

&lt;h3 id=&#34;how-it-works:3945feba508775401f06cd3bcd843e68&#34;&gt;How it works&lt;/h3&gt;

&lt;p&gt;Presenter First 의 강점은 접근방식의 단순하고 구체적인 모습이다. 개발은 다음과 같이 진행된다.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;생성자에서 Model 인터페이스와 View 인터페이스를 취하는 Stub Presenter 클래스를 만든다.&lt;/li&gt;
&lt;li&gt;Model, View의 인터페이스를 만족시키는 Mock 테스트 객체들을 만든다.&lt;/li&gt;
&lt;li&gt;모든 사용자 스토리들에 대해서

&lt;ul&gt;
&lt;li&gt;3.1 우선순위화 된 사용자 스토리를 선택한다.&lt;/li&gt;
&lt;li&gt;3.2 스토리의 View에 대한 영향력을 분석한다.&lt;/li&gt;
&lt;li&gt;3.3 스토리에 대한 View 인터페이스를 추가한다.&lt;/li&gt;
&lt;li&gt;3.4 스토리의 모델에 대한 영향력을 분석한다.&lt;/li&gt;
&lt;li&gt;3.5 스토리에 대한 Model 인터페이스를 추가한다.&lt;/li&gt;
&lt;li&gt;3.6 Mock 객체들에서, 호출되고 데이터들을 리턴 할 인터페이스 메서드들을 구현한다.&lt;/li&gt;
&lt;li&gt;3.7 끊어낼 수 있는 모든 요소들에 대해서(TDD 반복)

&lt;ul&gt;
&lt;li&gt;3.7.1 Do for each test

&lt;ul&gt;
&lt;li&gt;3.7.1.1 View 또는 Model에 대한 액션 또는 이벤트를 통해 앱을 활동시키는 Presenter에 대한 테스트를 작성하라.&lt;/li&gt;
&lt;li&gt;3.7.1.2 Model의 상태와 View의 상태에 대한 Assertion을 만들어라.&lt;/li&gt;
&lt;li&gt;3.7.1.3 Presenter 내의 private method들을 구현하라.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3.8 이 스토리의 View 인터페이스를 만족하는 최소의 사용자 인터페이스 구현체를 만들어라.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Presenter First 프로세스의 바깥 루프는 Model과 View 인터페이스의 빈번한 리팩토링들을 요구한다. 그러나 이러한 리팩토링들은, 해당 시점에서는 오직 이 인터페이스들에 대한 Mock 구현체밖에 존재하지 않기 때문에 비싼 비용이 들지 않는다.&lt;/p&gt;

&lt;p&gt;Presenter First의 한가지 매우 훌륭한 결과물은, Presenter가 현시점의 모든 고객 요구사항들을 코드화 했을 때, Model과 View의 인터페이스들은 그들 각자의 구현에 대한 최소의, 완전한 명세서가 된다는 것이다. 이 점에서 보면, 어플리케이션을 완성한다라는 것은 표준 TDD 실행에 따라 모델을 구현하고, 고객의 요구와 View 인터페이스를 총족시키기 위한 View를 만들어내는 것이 된다.&lt;/p&gt;

&lt;p&gt;고객으로부터 피드백을 얻기 위해, 우리는 일반적으로 최소한의 시간과 노력으로 상당히 단순한 사용자 인터페이스를 만들어낸다. 고객은 아마도 그런 인터페이스가 유능한 전문가에 의해 새롭게 디자인되야 한다거나, 마케팅적으로 디자인 되어야 한다거나, 혹은 이미 목적에 맞게 충분히 괜찮은지를 판단할 것이다. 그러는 동안에, 어플리케이션의 기능성은 테스트되고, 인터페이스 코드의 대해서는 오직 적은 노력만을 요구하며, 새로운 인터페이스들은 View 인터페이스를 만족시키는 미래의 어떤 순간에 즉시 개발되어질 것이다.&lt;/p&gt;

&lt;p&gt;실제의 View를 테스트하는 것은, 자동화를 위한 툴들과 예산이 허락된다면 테스트 자동화를 구축할 수 있다. 만약 그렇지 않을 경우에는 최종적으로 시스템 수동 테스트 단계를 진행하게 될 것이다. View는 Presenter가 처리할 적절한 타입 이벤트들을 호출하는 메서드 수 보다는 조금 더 많은 메서드 수를 가진 채 매우 얇게 되어있다. GUI 위젯이 동작하는(버튼 클릭 등등) 내부를 생각해보자. 그 View에 대한 유닛 테스트는 주로 스크린내에 위젯이 올바르게 놓여있는가, 적절한 이벤트 타입을 발생시키도록 프로그래밍 되어있는지를 확실히 하려는 것이다.&lt;/p&gt;

&lt;p&gt;Presenter는 의도적으로 비상태성이고 public 메서드가 없다. Presenter의 유닛 테스트들은 어플리케이션의 &amp;ldquo;wiring&amp;rdquo;이 Presenter의 private 메서드들이 표현하는대로 적절히 구현되었는지를 명시적으로 테스트한다. 어플리케이션의 기능은 Presenter에 의해 View와 Model 사이에서 조정된다. 이는 어플리케이션 행동에 대한 Presenter, Presenter의 유닛 테스트 묶음을 만들고, 응집력(cohesive)있고 집중화된(centralized) 문서 소스를 만들어준다. 실제로는 Presenter와 테스트들은 실재하는 실행가능한 어플리케이션 명세서다. 우리의 경험은, 어플리케이션 요구사항들의 변화와 추가는 종종 Presenter 에 의해 단독으로 처리(사용자 인터페이스의 변경이 아닐때)될 수 있다는 것이다. Presenter는 철저하게 유닛 테스트 커버리지를 가지기에, 이런 작업은, 고객의 관점에서 나오는 어플리케이션의 단순 변경과 추가 작업과 같은 것을 서포트 하기 위한 개발자의 수고를 단순하게 만들어, 빠르고 자신감있는 처리가 되어질 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;Presenter와의 커뮤니케이션은 Model과 View를 Presenter에 느슨하게 연결하기 위한 이벤트 서브시스템을 사용함으로써 가능해진다. 가장 흔한 케이스는, Model 트리거 이벤트도 또한 가능하겠지만, View의 이벤트를 Presenter가 소비하도록 발생시키는 것이다. View가 Presenter와의 커뮤니케이션에 이벤트를 사용하는것은 View의 로직을 매우 얇게 유지시킨다. View는 모든 이벤트 처리를 Presenter에 위임시킨다. 이런 디자인은 View 자체의 행동성에 대해 테스트할 것이 거의 없는 &amp;ldquo;얇은 GUI&amp;rdquo;를 만들어낸다. Presenter와의 커뮤니케이션에 이벤트를 사용하는 것은, 컴포넌트의 패키지를 분리하고, 컴파일 의존성들을 줄이고, 동일한 View가 다른 행동성을 가진 Presenter들에 연결되어질 수 있도록 한다.&lt;/p&gt;

&lt;p&gt;얇은 View의 결과, View 인터페이스는 Primitive 타입만을 파라미터로 취한다. 복잡한 타입들을 View에 전달하는 것은 View에서 Processing을 야기하고 View 층을 두텁게 하고, 유닛 테스트가 필요하도록 만든다.&lt;/p&gt;

&lt;h3 id=&#34;example-use-of-presenter-first:3945feba508775401f06cd3bcd843e68&#34;&gt;Example use of Presenter First&lt;/h3&gt;

&lt;h2 id=&#34;benefits-of-presenter-first:3945feba508775401f06cd3bcd843e68&#34;&gt;Benefits of Presenter First&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>안드로이드 앱 개발 시 주의사항</title>
      <link>http://brannpark.github.io/blog/posts/20151204_notices_for_android_app_development/</link>
      <pubDate>Fri, 04 Dec 2015 14:46:07 +0900</pubDate>
      
      <guid>http://brannpark.github.io/blog/posts/20151204_notices_for_android_app_development/</guid>
      <description>

&lt;p&gt;이 포스팅은 앞으로 쓰게 될 안드로이드 앱 개발 관련 주의사항 포스트들에 대한 게이트웨이 정도가 되겠다.
보통.. 이렇게 하면 좋다, 저렇게 하면 좋다라는 글들은 많고, 의견도 분분하고.. 하면 좋다 이지 안하면 안된다는것도 아니고.
그런데 이렇게 제발 쫌 하지 말라는 흘려버리기엔 너무 치명적이지 않을까? 왜 하지말라는지 꼭 알아봐야 한다고 생각한다. 그렇다고 누군가의 이야기를 그냥 맹신하는것은 위험! 과거엔 맞는 이야기가 현재에는 맞지 않을 수도 있으니&amp;hellip;&lt;/p&gt;

&lt;p&gt;간략하게 주제별로 리스팅을 하고, 원문 링크과 간략한 설명으로 작성해 나갈예정이다.&lt;/p&gt;

&lt;h1 id=&#34;안드로이드-앱-개발간-주의할-점들:ef042a2f7b58f2a52030c4028fc58f69&#34;&gt;안드로이드 앱 개발간 주의할 점들!&lt;/h1&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;http://www.developerphil.com/dont-store-data-in-the-application-object/&#34;&gt;Don&amp;rsquo;t Store Data in the Application Object&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Application 객체는 앱이 백그라운드에 진입해 있는 동안 시스템에 의해 recreate 될 수 있다. 그러므로 Application 의 적절한 라이프사이클(onCreate 같은)이 아닌 개별 액티비티의 라이프 사이클 내에서 Application 객체의 상태를 지정하는 코드는 위험하다. 사실 Application 객체 뿐 아니라, 모든 Activity 객체들에도 해당하는 말이다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class MyApplication extends Application {
    private String mName;

    public void setName(String name) {
        this.mName = name;
    }

    public String getName() {
        return mName;
    }
}


class FirstActivity extends Activity {

    void onCreate(Bundle bundle) {
        MyApplication app = (MyApplication)getApplication;
		app.setName(&amp;quot;AppName&amp;quot;);
	}
}


class SecondActivity extends Activity {
    void onCreate(Bundle bundle) {
	    MyApplication app = (MyApplication)getApplication;
		Toast.makeText(this, app.getName() + &amp;quot; is Application Name&amp;quot;, Toast.LENGTH_SHORT).show();  //  &amp;lt;-- app.getName() 은 상황에 따라서 Null 이 리턴될 수 있다. 따라서 이 코드는 NullPointerException 이 발생할 수 있는 잘못된 코드이다.
	}
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;static 변수들 또한 Device low memory 시점에 OS에 의해서 앱이 kill 되며 GC 될 수 있다. 따라서 singletone 패턴으로 사용되지 않는 static 객체 사용에 유의해야 한다. static 에 객체를 유지하고자 한다면 값이 assign 되는 시점이 액티비티의 적절한 라이프 사이클 내에 위치 시키거나 class load 타임 또는 객체 initialize 타임에 assign 될 수 있도록 해야한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class MainActivity extends AppCompatActivity {
    public static String name = &amp;quot;MainActivity&amp;quot;; // class initialize 시점에 값을 할당
    public static String name2;
    public static String name3;
	public static String name4;

    static { // class initialize 시점에 값을 할당
        name2 = &amp;quot;MainActivity2&amp;quot;;
	}

    { // object initialize 시점에 값을 할당
	    name4 = &amp;quot;MainActivity4&amp;quot;;
    }


    public static String getName() {
        return name;
    }
    public static String getName2() {
        return name2;
    }
    public static String getName3() {
        return name3;
	}
    public static String getName4() {		
	    return name4;
    }

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Intent intent = new Intent(MainActivity.this, SecondActivity.class);
                startActivity(intent);
            }
        });

        name3 = &amp;quot;MainActivity3&amp;quot;;
    }
}


public class SecondActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_second);
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);
        setSupportActionBar(toolbar);

        FloatingActionButton fab = (FloatingActionButton) findViewById(R.id.fab);
        fab.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View view) {
                Snackbar.make(view, &amp;quot;Replace with your own action&amp;quot;, Snackbar.LENGTH_LONG)
                        .setAction(&amp;quot;Action&amp;quot;, null).show();
            }
        });

        Toast.makeText(this, MainActivity.getName(), Toast.LENGTH_SHORT).show();
        Toast.makeText(this, MainActivity.getName2(), Toast.LENGTH_SHORT).show();
        Toast.makeText(this, MainActivity.getName3(), Toast.LENGTH_SHORT).show(); // LowMemory 시점에 OS에 의해 앱이 kill 된 후 recreate 되는 경우 getName3() 의 리턴값은 NULL 이다.
		Toast.makeText(this, MainActivity.getName4(), Toast.LENGTH_SHORT).show(); // getName3() 과 마찬가지로 recreate 시점에서 NULL 값을 리턴한다.
    }
    
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예제코드를 검증해보기 위해서는, 먼저 에뮬레이터를 띄워 앱을 실행 후 메인액티비티 화면에서 FAB 을 터치하여 SecondActivity 로 화면을 전환한 다음,
홈(HOME)버튼을 터치하여 앱을 백그라운드로 보낸다.
그리고 DDMS 를 이용하여 나의 앱 프로세스를 stop 버튼을 이용해 강제 종료시킨다.
그리고 다시 에뮬레이터에서 앱 히스토리 목록을 열고 앱으로 돌아가게 되면, 마지막 세번째 토스트의 경우 빈 문자열로 토스트 메시지가 뜨는 것을 확인 할 수 있다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSX El Capitan 개발환경 세팅</title>
      <link>http://brannpark.github.io/blog/posts/20151202_elcapitan_setup/</link>
      <pubDate>Wed, 02 Dec 2015 18:46:37 +0900</pubDate>
      
      <guid>http://brannpark.github.io/blog/posts/20151202_elcapitan_setup/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://herblover.github.io/&#34;&gt;Kenny&lt;/a&gt;님이 작성하신 OSX El Capitan 개발환경 세팅 포스트 공유합니다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://herblover.github.io/environments/mac/El-Capitan-Setup/&#34;&gt;http://herblover.github.io/environments/mac/El-Capitan-Setup&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Made by HUGO and GitHub Pages</title>
      <link>http://brannpark.github.io/blog/posts/20151201_hugo_with_github_pages/</link>
      <pubDate>Tue, 01 Dec 2015 15:36:31 +0900</pubDate>
      
      <guid>http://brannpark.github.io/blog/posts/20151201_hugo_with_github_pages/</guid>
      <description>

&lt;hr /&gt;

&lt;p&gt;일반적인 웹사이트의 경우, 여러 웹 컨텐츠들을 동적으로 생성하여 이용자에게 전달한다.&lt;/p&gt;

&lt;p&gt;다시 말해서, 웹어플리케이션은 동적 컨텐츠를 정적 컨텐츠로 변환하는 과정을 수행한다.&lt;/p&gt;

&lt;p&gt;그러다 보니, 이렇게 생성된 동적 컨텐츠는 일반적으로 브라우저 레벨에서의 캐싱을 이용할 수 없다. 따라서 매 페이지 요청시 마다 웹어플리케이션이 반복적인 일을 해야한다.&lt;/p&gt;

&lt;p&gt;그런데 정적 컨텐츠가 컨텐츠의 대부분을 차지하는 사이트의 경우에 따라서는 정적 웹사이트를 만들어서 운영해 볼 수 있다. 예전에는 정말 단순하고 반복적이지 않은 소수의 페이지들을 제공하는 목적으로 사용되었는데, 요즈음에는 관련 도구들이 매우 뛰어나졌다. 그 적용 방법이 나름 재미있다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;hugo:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Hugo&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://gohugo.io&#34;&gt;Hugo&lt;/a&gt; 는 Static Website Engine 이다. 이녀석은 사용자가 만든 컨텐츠를 이용, 이를 정적 웹사이트 컨텐츠로 만들어낸다.&lt;/p&gt;

&lt;p&gt;또한 특정 테마를 지정하여 빠르고 쉽게 사이트의 레이아웃과 스타일을 만들어 낼 수 있다.&lt;/p&gt;

&lt;p&gt;이 모든 과정은 사용자의 로컬 호스트에서 이뤄진다. 그러나 내 로컬에 결과물을 만들어낸 것만으로는 사이트를 인터넷에 띄울 수 없다.&lt;/p&gt;

&lt;p&gt;이 결과물을 GitHub, Amazon S3, 기타 클라우드 스토리지(public url access 가능한) 등에 업로드 하여 내 사이트를 인터넷에 띄우게 된다.&lt;/p&gt;

&lt;p&gt;본 블로그는 보다시피 Github Pages 를 이용하여 호스팅되고 있으며, Hugo 가이드를 마치고 호스팅에 대한 이야기를 이어 가겠다.&lt;/p&gt;

&lt;h2 id=&#34;installation:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;설치과정은 다음과 같다.&lt;/p&gt;

&lt;p&gt;본인은 Mac 을 쓰기에 Homebrew 를 이용한 설치 방법을 따랐지만, 그 외의 &lt;a href=&#34;https://github.com/spf13/hugo/releases&#34;&gt;다양한 플랫폼에 설치하는 방법&lt;/a&gt;을 제공한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ brew install hugo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;단순하다. hugo는 사이트 URL(gohugo.io) 에서도 알 수 있듯이 golang으로 작성되어있다. 따라서 의존 패키지 설치와 같은 귀찮은 과정 없이 심플하게 설치된다.&lt;/p&gt;

&lt;h2 id=&#34;create-hugo-project:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Create Hugo Project&lt;/h2&gt;

&lt;p&gt;/usr/local/bin 에 hugo 바이너리가 위치하며 이를 이용해 새 스켈레톤 프로젝트를 생성할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ cd /path/to/workspace
$ hugo new site &amp;lt;sitename&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;생성된 파일 및 디렉토리 구조는 다음과 같다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;  ▸ archetypes/
  ▸ content/
  ▸ data/
  ▸ layouts/
  ▸ static/
    config.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;자동 생성된 각 디렉토리에 대한 간단한 셜명을 하자면,&lt;/p&gt;

&lt;h3 id=&#34;archetypes:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;archetypes&lt;/h3&gt;

&lt;p&gt;hugo new 명령어로 컨텐츠를 생성 시, 자동으로 생성되는 header 템플릿을 생성하고자 하는 컨텐츠의 타입에 맞게 커스터마이징 가능하다.&lt;/p&gt;

&lt;p&gt;예를 들어, /content/musician 의 서브디렉토리 구조가 존재하는 경우,&lt;/p&gt;

&lt;p&gt;/archetypes/musician.md 라는 파일을 생성하여 내용을 다음과 같이 작성한다.&lt;/p&gt;

&lt;p&gt;만약 이름이 매칭되는 archetypes가 없고, /archetypes/default.md 가 존재하는 경우는 해당 파일의 내용을 header에 추가하게 된다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;+++
name = &amp;quot;&amp;quot;
bio = &amp;quot;&amp;quot;
genre = &amp;quot;&amp;quot;
+++
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 &lt;code&gt;hugo new musician/mozart.md&lt;/code&gt; 의 명령어를 수행하면
위에 지정된 name, bio, genre 구문이 header 에 추가로 자동 생성되는 것을 확인 할 수 있다.&lt;/p&gt;

&lt;h3 id=&#34;content:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;content&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;hugo new &amp;lt;path/to/&amp;gt;filename.md&lt;/code&gt; 명령어 수행 시 생성된 마크다운 문서가 저장되는 곳&lt;/p&gt;

&lt;h3 id=&#34;data:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;data&lt;/h3&gt;

&lt;p&gt;사이트 생성 시 필요한 추가적인 데이터를 저장할 수 있는 곳이다.
toml 의 형식으로 variable 을 선언하고 특정 데이터를 assign 가능하다.
또한 data 디렉토리의 하위 디렉토리 구조를 이용하여 데이터의 계층구조를 만들어 낼 수 있으며 같은 디렉토리내의 여러 toml 파일들은 Array 로 처리되어진다.
좀 복잡하게 다음과 같이 data 디렉토리가 구성되어있고&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/data/human/info/a.toml&lt;/code&gt;, &lt;code&gt;/data/human/info/b.toml&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;각각의 a.toml, b.toml 의 내용이 다음과 같다면&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[ a.toml ]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;name = &amp;quot;Steve&amp;quot;
age = 30
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;[ b.toml ]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;name = &amp;quot;Peter&amp;quot;
age = 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이를 html 템플릿에서 다음과 같이 사용할 수 있다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;{{ range $.Site.Data.human.info }}
&amp;lt;div&amp;gt;
  &amp;lt;p&amp;gt;Name : {{ .name }}&amp;lt;/p&amp;gt;
  &amp;lt;p&amp;gt;Age  : {{ .age }}&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;layouts:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;layouts&lt;/h3&gt;

&lt;p&gt;테마에서 사용되는 HTML 템플릿 파일들을 overwrite 할 수 있는 곳&lt;/p&gt;

&lt;h3 id=&#34;static:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;static&lt;/h3&gt;

&lt;p&gt;테마에서 사용되는 asset 을 overwrite 하거나, 추가 asset 들을 제공할 수 있는 곳&lt;/p&gt;

&lt;h2 id=&#34;select-theme:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Select Theme&lt;/h2&gt;

&lt;p&gt;Hugo 에는 다양한 오픈소스 테마들이 존재한다.
&lt;a href=&#34;http://themes.gohugo.io&#34;&gt;이곳&lt;/a&gt;에서 Hugo 의 다양한 테마들을 살펴볼 수 있다.&lt;/p&gt;

&lt;p&gt;본 블로그에 적용된 테마는 &lt;a href=&#34;http://themes.gohugo.io/redlounge/&#34;&gt;RedLounge&lt;/a&gt; 라는 테마이다.&lt;/p&gt;

&lt;p&gt;먼저, 적용하고자 하는 테마의 git 저장소 URL을 확인한다. 그리고, 사이트 프로젝트 root 에서 다음과 같은 명령어들을 수행한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ mkdir themes
$ cd themes
$ git clone &amp;lt;repository_url_of_theme&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;다운받은 테마를 살펴보면, 기본 구조가 &lt;code&gt;hugo new site&lt;/code&gt; 를 통해 만들어진 구조와 거의 흡사하다는것을 알 수 있다.&lt;/p&gt;

&lt;p&gt;RedLounge 테마를 기준으로 분석해보니&amp;hellip;&lt;/p&gt;

&lt;p&gt;content 와 data 디렉토리가 없는 대신 images 디렉토리가 존재한다.&lt;/p&gt;

&lt;p&gt;또한, config.toml 대신 theme.toml 설정파일이 존재한다.&lt;/p&gt;

&lt;p&gt;images 디렉토리는 Hugo의 ThemeShowcase 를 위한 이미지파일을 제공하며, theme.toml 또한 테마에 대한 설명, 버젼, 작성자 등에 대한 정보를 제공하는데에 쓰인다.&lt;/p&gt;

&lt;p&gt;hugo 는 프로젝트를 빌드 시, 테마의 파일시스템을 임시 파일시스템위에 카피하고, 다시 이곳에 사용자 프로젝트의 파일시스템을 덮어씌운 결과물을 빌드하는 것으로 보인다. 그러므로 theme 의 레이아웃 파일을 overwrite 하고 싶다면 동일한 stucture 내의 동일한 이름의 컨텐츠 파일을 생성하여 overwrite 가능하다.&lt;/p&gt;

&lt;h2 id=&#34;configuration:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Configuration&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;config.[toml|yaml|json]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Hugo 프로젝트의 설정파일. toml, yaml, json 모두 사용 가능하다.
기본적인 빌드관련 설정과 테마별 추가 파라미터 변수들의 설정또한 이곳에서 처리한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;[ config.toml]&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;contentdir = &amp;quot;content&amp;quot;
layoutdir = &amp;quot;layouts&amp;quot;
staticdir = &amp;quot;static&amp;quot;
publishdir = &amp;quot;dist&amp;quot;
baseurl = &amp;quot;http://brannpark.github.io/blog&amp;quot;
title = &amp;quot;개발지식저장소&amp;quot;
theme = &amp;quot;redlounge&amp;quot;
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 내용은 본 블로그 hugo 프로젝트의 configuration 중 일부로써 여기서 중요한 부분은 publishdir, baseurl, theme 정도가 되겠다.&lt;/p&gt;

&lt;p&gt;publishdir 의 경우 기본값은 publish 인데, 여기서는 dist 라고 지정되어있다. 이는 GitHub Pages 에 배포하기 위해 사용할 배포 스크립트가 기본적으로 소스 디렉토리 이름을 dist로 사용하기 때문이다. 관련 내용은 젤 마지막 Deploying To GitHub Pages 섹션에서 확인 할 수 있다.&lt;/p&gt;

&lt;p&gt;baseurl 은 위와같이 본인의 블로그 사이트 베이스 url 을 입력하면 되고, theme 는 themes 디렉토리 하위의 사용할 테마 디렉토리 이름을 입력하면 된다. 참고로 RedLounge 의 경우 저장소를 그대로 clone 할 경우 디렉토리 이름이 hugo-redlounge 인데 redlounge 로 리네임하였기에 위와같이 적용하하였다.&lt;/p&gt;

&lt;p&gt;추가 Hugo Configuration 에 대한 도큐먼트는 &lt;a href=&#34;https://gohugo.io/overview/configuration/&#34;&gt;이곳&lt;/a&gt;을 참조하여 확인하자.&lt;/p&gt;

&lt;p&gt;또한 각각의 테마에서 커스텀하게 사용하는 파라미터 설정들은 guide document 에 명시되어있다. &lt;a href=&#34;https://github.com/tmaiaroto/hugo-redlounge&#34;&gt;예시(RedLounge)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;create-page:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Create Page&lt;/h2&gt;

&lt;p&gt;새 페이지를 만들기 위해서는 다음과 같은 명령어를 이용한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new content/newpost.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;혹은 서브 URL 형태로 컨텐츠를 제공 하고자 한다면,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo new content/&amp;lt;subdir&amp;gt;/newpost.md
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;와 같이 명령어를 수행하여 새 컨텐츠를 생성한다.&lt;/p&gt;

&lt;p&gt;이렇게 생성된 md 파일은 다음과 같은 특수한 header 부분을 가진다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;+++
Categories = [&amp;quot;Development&amp;quot;]
Description = &amp;quot;Hugo와 GitHub Pages 를 이용한 블로그 구축 가이드&amp;quot;
Tags = [&amp;quot;hugo&amp;quot;, &amp;quot;redlounge&amp;quot;, &amp;quot;static-website-engine&amp;quot;, &amp;quot;github-pages&amp;quot;]
date = &amp;quot;2015-12-01T15:36:31+09:00&amp;quot;
title = &amp;quot;Made by HUGO and GitHub Pages&amp;quot;
+++

&amp;lt;Markdown Content&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이는, 본 게시글에 적용된 header 로 각각은 테마와 연동되어 사이트의 UI에 표시된다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-site-on-local:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Deploying Site on Local&lt;/h1&gt;

&lt;p&gt;이제 사이트를 로컬환경에서 띄워 볼 준비가 되었다고 볼 수 있다.
프로젝트의 루트에서 다음과 같은 명령어를 쳐보자&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ hugo server --watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그러면 config 에 설정된 baseurl 을 따라서 호스트 부분 &lt;code&gt;127.0.0.1:1313&lt;/code&gt; 으로 변경되어 웹서버가 띄워진다.&lt;/p&gt;

&lt;p&gt;브라우저로 &lt;code&gt;http://localhost:1313/blog&lt;/code&gt; 로 접속하여 확인 가능하다. (위에 예시로 작성된 설정파일의 baseurl 의 base path 가 &lt;strong&gt;blog&lt;/strong&gt; 이다.)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--watch&lt;/code&gt; 옵션은 특정 파일시스템에 변화가 생기면 자동으로 rebuild 하여 반영해주는 기능을 활성화 한다.&lt;/p&gt;

&lt;p&gt;로컬에서 글 수정, 추가 작업 시 요긴하게 쓰인다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;github-pages:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;GitHub Pages&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://pages.github.com&#34;&gt;Pages&lt;/a&gt; 는 github repository 를 기반으로 웹사이트를 호스팅해주는 기능이다.&lt;/p&gt;

&lt;p&gt;github의 username 을 이용하여, 다음과 같이 내 github.io 에 접근할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;그러나 위와 같은 식으로 접근하여 사이트를 호스팅 하려면 다음과 같은 특수한 이름의 저장소를 만들어야 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;username&amp;gt;.github.io&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 저장소의 master 브랜치에 index.html 을 만들어 remote 에 푸쉬해 두면, 위 링크 접속 시 해당 페이지를 브라우저에서 볼 수 있다.&lt;/p&gt;

&lt;p&gt;이를 Pages 에서는 User/Organization Site 라 한다.&lt;/p&gt;

&lt;p&gt;이와 별개로, 각각의 저장소들은 각각의 Pages 를 가질 수 있는데, 이를 Project site 라 한다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io/&amp;lt;repository_name&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 blog 라는 저장소를 가지고 있다면, blog 저장소에 gh-pages 라는 브랜치를 orphan 모드로 생성(기존의 브랜치, 커밋들에서 완전히 독립적인 새 브랜치)하여 index.html 만들어 remote 에 푸쉬 해 두면&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io/blog&lt;/code&gt; 에 접속 시 해당 페이지를 브라우저에서 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;br&gt;&lt;/p&gt;

&lt;h1 id=&#34;deploying-to-github-pages:d818b8a7948ca63ccc8c7bf194ac8a9f&#34;&gt;Deploying to GitHub Pages&lt;/h1&gt;

&lt;p&gt;Project site 형식으로 GitHub Pages 에 블로그 사이트를 호스팅하는 예를 들겠다.&lt;/p&gt;

&lt;p&gt;GitHub 저장소 이름이 blog 라고 한다면,&lt;/p&gt;

&lt;p&gt;Pages 에서 호스팅되는 내 블로그 사이트의 base URL 은 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;http://&amp;lt;username&amp;gt;.github.io/blog&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;이 주소로 GET request 하게 되면 Pages 는 blog 라는 저장소의 gh-pages 브랜치의 index.html 을 serving 한다.
먼저, blog 저장소의 master 브랜치에는 Hugo 프로젝트가 생성되어 있다고 가정한다.&lt;/p&gt;

&lt;p&gt;이제 gh-pages 브랜치를 생성하자. 위에 설명한 대로 orphan 모드로 생성한다.&lt;/p&gt;

&lt;p&gt;그리고 브랜치를 git rm 명령어를 이용해 모두 삭제, add, commit 하고 origin 에 푸쉬 후, master 브랜치로 체크아웃한다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git clone https://github.com/&amp;lt;username&amp;gt;/blog.git
$ cd blog
$ git checkout -b --orphan gh-pages
$ git rm -rf .
$ git add .
$ git commit -am &amp;quot;initial commit&amp;quot;
$ git push origin gh-pages
$ git checkout master
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;그리고 다음과 같이 deployment script 를 내려받아 excutable 퍼미션을 할당한다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ wget https://github.com/X1011/git-directory-deploy/raw/master/deploy.sh &amp;amp;&amp;amp; chmod +x deploy.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;본인의 경우 해당 스크립트의 설정값 변경없이 바로 사용하였어도 문제없이 배포가 되었지만,&lt;/p&gt;

&lt;p&gt;혹여나 문제가 발생하였다면 해당 스크립트에 대한 &lt;a href=&#34;https://github.com/X1011/git-directory-deploy&#34;&gt;가이드&lt;/a&gt;를 꼭 확인해보자.&lt;/p&gt;

&lt;p&gt;스크립트를 다운 받았으면 hugo 를 이용해 프로젝트를 빌드하고 결과물을 deploy 스크립트를 이용해 블로그를 배포할 준비가 모두 되었다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ hugo -d dist
$ ./deploy.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;hugo -d dist&lt;/code&gt; 명령어를 통해 프로젝트를 빌드하여 dist에 빌드 결과물을 저장하고, &lt;code&gt;./deploy.sh&lt;/code&gt; 를 이용해 gh-pages 브랜치에 배포하게 된다.&lt;/p&gt;

&lt;p&gt;여기서 중요한것은 dist 라는 디렉토리인데, deploy 스크립트는 기본값으로 dist 라는 디렉토리를 배포 소스 디렉토리로 설정되어있다는 점이다.&lt;/p&gt;

&lt;p&gt;어찌되었든 성공적으로 수행되었다면, 잠시 후 &lt;code&gt;http://&amp;lt;username&amp;gt;.github.io/blog&lt;/code&gt; 로 접속 시 내 블로그 사이트를 볼 수 있다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>블로그를 시작합니다</title>
      <link>http://brannpark.github.io/blog/posts/new/</link>
      <pubDate>Tue, 01 Dec 2015 11:47:56 +0900</pubDate>
      
      <guid>http://brannpark.github.io/blog/posts/new/</guid>
      <description>&lt;hr /&gt;

&lt;p&gt;뭐.. 평소에도 계속 프로그래밍 관련 글들을 기록해놓는 블로그를 해볼까 했었습니다만,&lt;/p&gt;

&lt;p&gt;생각보다 시작이 쉽지가 않더군요 ㅎㅎ..&lt;/p&gt;

&lt;p&gt;Github Pages 를 이용한 static website 개설에 흥미가 생겨서 한번 이를 이용한 블로깅을 시작해 볼까 합니다!&lt;/p&gt;

&lt;p&gt;아마도 첫번째 주제는 사이트 개설기 정도가 되겠네요 ㅎㅎ&lt;/p&gt;

&lt;p&gt;글이 마무리되면 포스팅 하도록 하겠습니다!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>